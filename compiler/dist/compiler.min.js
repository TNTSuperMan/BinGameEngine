const n=n=>n+"/ 2 rem\n",r=n=>n+"/ 0 nand 2 rem\n",t=(r,t)=>n(r)+n(t)+"/ add 1 greater\n",o=(n,t)=>r(n+t+"/ nand\n"),e=(n,r,t=[])=>{let o=n+"\n";const e=":"+crypto.randomUUID(),a=":"+crypto.randomUUID();return o+=`/ ${e} truejump\n`,o+=t.join("\n"),o+=`\n/ ${a} jump\n`,o+=`\n${e}\n`,o+=r.join("\n"),o+=`\n${a}\n`,o},a=(n,t)=>{let o="";const e=":"+crypto.randomUUID(),a=":"+crypto.randomUUID();return o+=e+"\n",o+=r(n)+"/ "+a+" truejump\n",o+=t.join("\n"),o+="/ "+e+" jump\n",o+=a+"\n",o},d=n=>"/ "+n.toString(16)+" load\n";let m=0;const u=()=>{if(m>=20479)throw new RangeError("Too many vars");return m++};let c="";const l=(n,r)=>{let t=[];for(let n=0;n<r.length;n++)t.push(u());const o=":"+n+crypto.randomUUID();return c+=o+"\n",c+=r(...t)+"\n",(...n)=>n.join("")+`\n/ ${o} call\n`},p=n=>"/ "+n.toString(16)+"\n",s=n=>p(n),U=()=>"/ pop\n",i=()=>"/ cls\n",j=(n,r)=>n+r+"/ add\n",g=(n,r)=>n+r+"/ sub\n",y=(n,r)=>n+r+"/ mul\n",D=(n,r)=>n+r+"/ div\n",I=(n,r)=>n+r+"/ rem\n",$=(n,r)=>n+r+"/ nand\n",h=(n,r)=>n+r+"/ equal\n",f=(n,r)=>n+r+"/ greater\n",v=(n,r)=>p(n)+r+"store\n";export{e as If,a as While,j as add,o as and,n as boolify,i as cls,l as defn,u as defvar,D as div,h as equal,f as greater,y as mul,$ as nand,r as not,s as num,t as or,U as pop,I as rem,v as set,g as sub,d as vr};
